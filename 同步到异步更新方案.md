# FastAPI同步项目升级为异步项目规划清单（含具体代码）

## 一、依赖包升级

**需要修改的文件：** `pyproject.toml`

| 序号 | 操作                              | 说明                           |
| ---- | --------------------------------- | ------------------------------ |
| 1.1  | 添加 `aiomysql>=0.2.0`            | MySQL异步驱动                  |
| 1.2  | 添加 `asyncpg>=0.30.0`            | PostgreSQL异步驱动（如果需要） |
| 1.3  | 添加 `sqlalchemy[asyncio]>=2.0.0` | SQLAlchemy异步支持             |

**当前代码：**
```toml
[project]
name = "py-fastapi-template"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.12"
dependencies = [
    "fastapi>=0.125.0",
    "pwdlib[argon2]>=0.3.0",
    "pydantic-settings>=2.12.0",
    "pyjwt>=2.10.1",
    "pymysql>=1.1.2",
    "python-multipart>=0.0.21",
    "sqlmodel>=0.0.27",
    "uvicorn>=0.38.0",
]
```

**修改后代码：**
```toml
[project]
name = "py-fastapi-template"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.12"
dependencies = [
    "aiomysql>=0.3.2",
    "fastapi>=0.125.0",
    "pwdlib[argon2]>=0.3.0",
    "pydantic-settings>=2.12.0",
    "pyjwt>=2.10.1",
    "pymysql>=1.1.2",
    "python-multipart>=0.0.21",
    "sqlalchemy[asyncio]>=2.0.45",
    "sqlmodel>=0.0.27",
    "uvicorn>=0.38.0",
]
```

**状态：** ✅ 已完成（依赖已升级）

---

## 二、数据库引擎层升级

**需要修改的文件：** `app/core/db.py`

**当前代码：**
```python
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy.ext.declarative import declarative_base

from app.core.config import settings

# 创建数据库引擎
engine = create_async_engine(str(settings.SQLALCHEMY_DATABASE_URI_MYSQL), echo=settings.DEBUG_MYSQL)

# 创建基础模型类
Base = declarative_base()

# 导入所有模型类，确保它们被注册到 Base 中 这样 create_all() 才能找到并创建所有的表
# 避免无关的警告，如未使用的导入、行太长等 noqa
from app.models import users_models  # noqa

def create_tables():
    """创建数据库表
    检查数据库是否有表，没有则创建，有则不做处理
    """
    try:
        Base.metadata.create_all(bind=engine)
        print("数据库表检查完成: 已存在的表保持不变，不存在的表已创建")
    except Exception as e:
        print(f"数据库表创建失败: {e}")
        raise

def shutdown_db():
    """关闭数据库
    删除全部会话，关闭引擎
    """
    try:
        # 关闭引擎，释放所有连接池资源
        engine.dispose()
        print("数据库已关闭: 所有会话已删除，引擎已关闭")
    except Exception as e:
        print(f"数据库关闭失败: {e}")
        raise
```

**修改后代码：**
```python
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from sqlalchemy.ext.declarative import declarative_base

from app.core.config import settings

# 创建数据库引擎
engine = create_async_engine(str(settings.SQLALCHEMY_DATABASE_URI_MYSQL), echo=settings.DEBUG_MYSQL)

# 创建异步会话工厂
async_session_maker = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# 创建基础模型类
Base = declarative_base()

# 导入所有模型类，确保它们被注册到 Base 中 这样 create_all() 才能找到并创建所有的表
# 避免无关的警告，如未使用的导入、行太长等 noqa
from app.models import users_models  # noqa

async def create_tables():
    """创建数据库表
    检查数据库是否有表，没有则创建，有则不做处理
    """
    try:
        async with engine.begin() as conn:
            await conn.run_sync(Base.metadata.create_all)
        print("数据库表检查完成: 已存在的表保持不变，不存在的表已创建")
    except Exception as e:
        print(f"数据库表创建失败: {e}")
        raise

async def shutdown_db():
    """关闭数据库
    删除全部会话，关闭引擎
    """
    try:
        # 关闭引擎，释放所有连接池资源
        await engine.dispose()
        print("数据库已关闭: 所有会话已删除，引擎已关闭")
    except Exception as e:
        print(f"数据库关闭失败: {e}")
        raise
```

**关键变化：**
- ✅ 导入 `async_sessionmaker` 和 `AsyncSession`
- ✅ 创建 `async_session_maker` 会话工厂
- ✅ `create_tables()` 改为 `async def`，使用 `await conn.run_sync()`
- ✅ `shutdown_db()` 改为 `async def`，使用 `await engine.dispose()`

---

## 三、数据库会话依赖升级

**需要修改的文件：** `app/api/deps.py`

**当前代码：**

```python
from typing import Generator, Annotated

import jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jwt import InvalidTokenError
from pydantic import ValidationError
from sqlalchemy.exc import SQLAlchemyError
from sqlmodel import Session

from app.core.config import settings
from app.core.db_mysql import engine
from app.crud.users_crud import get_user_by_sub, UserIn
from app.models.token_models import TokenPayload

# 定义 OAuth2 密码Bearer 依赖项
# 用于在路由 /access-token 中获取访问令牌
reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)

TokenDep = Annotated[str, Depends(reusable_oauth2)]


def get_db() -> Generator[Session, None, None]:
    """
    数据库会话依赖项
    用于在 FastAPI 路由中获取数据库会话，确保在请求处理完成后自动关闭会话

    Yields:
        Session: 数据库会话实例
    """
    with Session(engine) as session:
        try:
            yield session
        except SQLAlchemyError:
            session.rollback()
        finally:
            session.close()


SessionDep = Annotated[Session, Depends(get_db)]


def get_current_user(session: SessionDep, token: TokenDep) -> UserIn:
    """
    获取当前用户
    用于在 FastAPI 路由中获取当前认证用户，根据 JWT 令牌中的 subject (sub) 字段查询数据库

    Args:
        session (SessionDep): 数据库会话依赖项
        token (TokenDep): JWT 令牌依赖项

    Returns:
        UserIn: 当前认证用户对象

    Raises:
        HTTPException: 403 权限拒绝，验证失败或用户不存在
        HTTPException: 404 用户不存在，数据库查询结果为空
        HTTPException: 400 禁用用户，用户状态为 False
    """
    try:
        # 解码 JWT 令牌
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        token_data = TokenPayload(**payload)
    except (InvalidTokenError, ValidationError):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Could not validate credentials",
        )
    # 从数据库中查询用户
    user = get_user_by_sub(session=session, sub=token_data.sub)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    if not user.status:
        raise HTTPException(status_code=400, detail="Inactive user")
    return user


CurrentUser = Annotated[UserIn, Depends(get_current_user)]
```

**修改后代码：**

```python
from typing import AsyncGenerator, Annotated

import jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jwt import InvalidTokenError
from pydantic import ValidationError
from sqlalchemy.exc import SQLAlchemyError
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.config import settings
from app.core.db_mysql import async_session_maker
from app.crud.users_crud import get_user_by_sub, UserIn
from app.models.token_models import TokenPayload

# 定义 OAuth2 密码Bearer 依赖项
# 用于在路由 /access-token 中获取访问令牌
reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)

TokenDep = Annotated[str, Depends(reusable_oauth2)]


async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    数据库会话依赖项
    用于在 FastAPI 路由中获取数据库会话，确保在请求处理完成后自动关闭会话

    Yields:
        AsyncSession: 数据库会话实例
    """
    async with async_session_maker() as session:
        try:
            yield session
        except SQLAlchemyError:
            await session.rollback()
        finally:
            await session.close()


SessionDep = Annotated[AsyncSession, Depends(get_db)]


async def get_current_user(session: SessionDep, token: TokenDep) -> UserIn:
    """
    获取当前用户
    用于在 FastAPI 路由中获取当前认证用户，根据 JWT 令牌中的 subject (sub) 字段查询数据库

    Args:
        session (SessionDep): 数据库会话依赖项
        token (TokenDep): JWT 令牌依赖项

    Returns:
        UserIn: 当前认证用户对象

    Raises:
        HTTPException: 403 权限拒绝，验证失败或用户不存在
        HTTPException: 404 用户不存在，数据库查询结果为空
        HTTPException: 400 禁用用户，用户状态为 False
    """
    try:
        # 解码 JWT 令牌
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        token_data = TokenPayload(**payload)
    except (InvalidTokenError, ValidationError):
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Could not validate credentials",
        )
    # 从数据库中查询用户
    user = await get_user_by_sub(session=session, sub=token_data.sub)
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    if not user.status:
        raise HTTPException(status_code=400, detail="Inactive user")
    return user


CurrentUser = Annotated[UserIn, Depends(get_current_user)]
```

**关键变化：**
- ✅ `Generator` → `AsyncGenerator`
- ✅ `Session` → `AsyncSession`
- ✅ `from sqlmodel import Session` → `from sqlalchemy.ext.asyncio import AsyncSession`
- ✅ `from app.core.db import engine` → `from app.core.db import async_session_maker`
- ✅ `def get_db()` → `async def get_db()`
- ✅ `with Session(engine)` → `async with async_session_maker()`
- ✅ `session.rollback()` → `await session.rollback()`
- ✅ `session.close()` → `await session.close()`
- ✅ `def get_current_user()` → `async def get_current_user()`
- ✅ `get_user_by_sub()` → `await get_user_by_sub()`

---

## 四、CRUD层升级

**需要修改的文件：** `app/crud/users_crud.py`

**当前代码：**
```python
from pydantic import BaseModel
from sqlmodel import Session, select

from app.core.security import verify_password, get_password_hash
from app.models.users_models import UserModel


class UserIn(BaseModel):
    """
    用户信息查询内部模型，包含用户基本信息
    """
    username: str
    email: str | None = None
    nickname: str | None = None
    phone: str | None = None
    avatar: str | None = None
    intro: str | None = None
    role_id: int | None = None
    status: bool = True

class UserInfo(UserIn):
    """
    用户信息验证模型，包含用户ID
    """
    id: int

class UserCreate(UserIn):
    """
    用户注册模型，包含用户注册信息
    """
    password: str


def get_user_by_sub(*, session: Session, sub: str) -> UserInfo | None:
    """
    根据 sub 查询用户
    :param session: 数据库会话
    :param sub: 用户唯一标识符
    :return: 用户对象
    """
    statement = select(UserModel).where(UserModel.id == int(sub))
    user = session.exec(statement).first()
    if user:
        return UserInfo(**user.__dict__)
    return None

def authenticate(*, session: Session, username: str, password: str) -> UserInfo | None:
    """
    验证用户密码
    :param session: 数据库会话
    :param username: 用户名
    :param password: 密码
    :return: 用户对象
    """
    statement = select(UserModel).where(UserModel.username == username)
    user = session.exec(statement).first()
    if not user:
        return None
    if not verify_password(password, user.password):
        return None
    return UserInfo(**user.__dict__)

def get_user_by_username(*, session: Session, username: str) -> UserInfo | None:
    """
    根据用户名查询用户
    :param session: 数据库会话
    :param username: 用户名
    :return: 用户对象
    """
    statement = select(UserModel).where(UserModel.username == username)
    user = session.exec(statement).first()
    if user:
        return UserInfo(**user.__dict__)
    return None

def create_user(*, session: Session, user: UserCreate) -> UserModel:
    """
    创建新用户
    :param session: 数据库会话
    :param user: 用户注册信息
    :return: 用户对象
    """
    # 密码哈希
    user.password = get_password_hash(user.password)
    # 创建用户
    db_user = UserModel(**user.model_dump())
    session.add(db_user)
    session.commit()
    session.refresh(db_user)
    return db_user
```

**修改后代码：**
```python
from pydantic import BaseModel
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from app.core.security import verify_password, get_password_hash
from app.models.users_models import UserModel


class UserIn(BaseModel):
    """
    用户信息查询内部模型，包含用户基本信息
    """
    username: str
    email: str | None = None
    nickname: str | None = None
    phone: str | None = None
    avatar: str | None = None
    intro: str | None = None
    role_id: int | None = None
    status: bool = True

class UserInfo(UserIn):
    """
    用户信息验证模型，包含用户ID
    """
    id: int

class UserCreate(UserIn):
    """
    用户注册模型，包含用户注册信息
    """
    password: str


async def get_user_by_sub(*, session: AsyncSession, sub: str) -> UserInfo | None:
    """
    根据 sub 查询用户
    :param session: 数据库会话
    :param sub: 用户唯一标识符
    :return: 用户对象
    """
    statement = select(UserModel).where(UserModel.id == int(sub))
    result = await session.execute(statement)
    user = result.scalar_one_or_none()
    if user:
        return UserInfo(**user.__dict__)
    return None

async def authenticate(*, session: AsyncSession, username: str, password: str) -> UserInfo | None:
    """
    验证用户密码
    :param session: 数据库会话
    :param username: 用户名
    :param password: 密码
    :return: 用户对象
    """
    statement = select(UserModel).where(UserModel.username == username)
    result = await session.execute(statement)
    user = result.scalar_one_or_none()
    if not user:
        return None
    if not verify_password(password, user.password):
        return None
    return UserInfo(**user.__dict__)

async def get_user_by_username(*, session: AsyncSession, username: str) -> UserInfo | None:
    """
    根据用户名查询用户
    :param session: 数据库会话
    :param username: 用户名
    :return: 用户对象
    """
    statement = select(UserModel).where(UserModel.username == username)
    result = await session.execute(statement)
    user = result.scalar_one_or_none()
    if user:
        return UserInfo(**user.__dict__)
    return None

async def create_user(*, session: AsyncSession, user: UserCreate) -> UserModel:
    """
    创建新用户
    :param session: 数据库会话
    :param user: 用户注册信息
    :return: 用户对象
    """
    # 密码哈希
    user.password = get_password_hash(user.password)
    # 创建用户
    db_user = UserModel(**user.model_dump())
    session.add(db_user)
    await session.commit()
    await session.refresh(db_user)
    return db_user
```

**关键变化：**
- ✅ `from sqlmodel import Session, select` → `from sqlalchemy import select` + `from sqlalchemy.ext.asyncio import AsyncSession`
- ✅ 所有函数改为 `async def`
- ✅ `session: Session` → `session: AsyncSession`
- ✅ `session.exec(statement).first()` → `await session.execute(statement); result.scalar_one_or_none()`
- ✅ `session.commit()` → `await session.commit()`
- ✅ `session.refresh(db_user)` → `await session.refresh(db_user)`

---

## 五、路由层升级

### 5.1 用户路由

**需要修改的文件：** `app/api/routes/v1/users.py`

**当前代码：**
```python
from fastapi import APIRouter, HTTPException, status

from app.api.deps import SessionDep, CurrentUser
from app.crud.users_crud import UserCreate, get_user_by_username, create_user, UserIn
from app.models.base_models import APIRes

router = APIRouter(prefix="/users", tags=["users"])

@router.post("/register", response_model=APIRes[bool])
def register_user(*, session: SessionDep, user: UserCreate):
    """
    注册新用户

    Args:
        session: 数据库会话
        user: 用户注册信息

    Returns:
        bool: 注册成功返回True，否则返回False
    """

    # 检查用户名是否已存在
    existing_user = get_user_by_username(session=session, username=user.username)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered"
        )

    # 创建新用户
    res = create_user(session=session, user=user) is not None
    return APIRes(data=res, message="User registered successfully")

@router.get("/me", response_model=APIRes[UserIn])
def get_current_user(*, current_user: CurrentUser):
    """
    获取当前登录用户信息

    Args:
        current_user: 当前登录用户

    Returns:
        UserIn: 当前登录用户信息
    """
    return APIRes(data=current_user, message="User info retrieved successfully")
```

**修改后代码：**
```python
from fastapi import APIRouter, HTTPException, status

from app.api.deps import SessionDep, CurrentUser
from app.crud.users_crud import UserCreate, get_user_by_username, create_user, UserIn
from app.models.base_models import APIRes

router = APIRouter(prefix="/users", tags=["users"])

@router.post("/register", response_model=APIRes[bool])
async def register_user(*, session: SessionDep, user: UserCreate):
    """
    注册新用户

    Args:
        session: 数据库会话
        user: 用户注册信息

    Returns:
        bool: 注册成功返回True，否则返回False
    """

    # 检查用户名是否已存在
    existing_user = await get_user_by_username(session=session, username=user.username)
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Username already registered"
        )

    # 创建新用户
    res = await create_user(session=session, user=user) is not None
    return APIRes(data=res, message="User registered successfully")

@router.get("/me", response_model=APIRes[UserIn])
async def get_current_user(*, current_user: CurrentUser):
    """
    获取当前登录用户信息

    Args:
        current_user: 当前登录用户

    Returns:
        UserIn: 当前登录用户信息
    """
    return APIRes(data=current_user, message="User info retrieved successfully")
```

**关键变化：**
- ✅ `def register_user()` → `async def register_user()`
- ✅ `get_user_by_username()` → `await get_user_by_username()`
- ✅ `create_user()` → `await create_user()`
- ✅ `def get_current_user()` → `async def get_current_user()`

---

### 5.2 登录路由

**需要修改的文件：** `app/api/routes/v1/login.py`

**当前代码：**
```python
from datetime import timedelta
from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import OAuth2PasswordRequestForm

from app.api.deps import SessionDep
from app.core import security
from app.core.config import settings
from app.crud import users_crud
from app.models.token_models import Token

router = APIRouter(tags=["login"])

@router.post("/login/access-token")
def login_access_token(
    session: SessionDep, form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
) -> Token:
    """
    OAuth2 与 Jwt 登录接口，用于获取访问令牌
    :param session: 数据库会话依赖项
    :param form_data: 包含用户名和密码的表单数据
    :return: 包含访问令牌的Token模型
    """
    user = users_crud.authenticate(
        session=session, username=form_data.username, password=form_data.password
    )
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect email or password")
    elif not user.status:
        raise HTTPException(status_code=400, detail="Inactive user")
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    return Token(
        access_token=security.create_access_token(
            str(user.id), expires_delta=access_token_expires
        )
    )
```

**修改后代码：**
```python
from datetime import timedelta
from typing import Annotated

from fastapi import APIRouter, Depends, HTTPException
from fastapi.security import OAuth2PasswordRequestForm

from app.api.deps import SessionDep
from app.core import security
from app.core.config import settings
from app.crud import users_crud
from app.models.token_models import Token

router = APIRouter(tags=["login"])

@router.post("/login/access-token")
async def login_access_token(
    session: SessionDep, form_data: Annotated[OAuth2PasswordRequestForm, Depends()]
) -> Token:
    """
    OAuth2 与 Jwt 登录接口，用于获取访问令牌
    :param session: 数据库会话依赖项
    :param form_data: 包含用户名和密码的表单数据
    :return: 包含访问令牌的Token模型
    """
    user = await users_crud.authenticate(
        session=session, username=form_data.username, password=form_data.password
    )
    if not user:
        raise HTTPException(status_code=400, detail="Incorrect email or password")
    elif not user.status:
        raise HTTPException(status_code=400, detail="Inactive user")
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    return Token(
        access_token=security.create_access_token(
            str(user.id), expires_delta=access_token_expires
        )
    )
```

**关键变化：**
- ✅ `def login_access_token()` → `async def login_access_token()`
- ✅ `users_crud.authenticate()` → `await users_crud.authenticate()`

---

## 六、配置文件升级

**需要修改的文件：** `app/core/config.py`

**当前代码：**
```python
@computed_field  # type: ignore[prop-decorator]
@property
def SQLALCHEMY_DATABASE_URI_MYSQL(self) -> str:
    """生成 MySQL 数据库连接 URL"""
    return f"mysql+aiomysql://{self.MYSQL_USER}:{self.MYSQL_PASSWORD}@{self.MYSQL_SERVER}:{self.MYSQL_PORT}/{self.MYSQL_DB}?charset=utf8mb4"
```

**修改后代码：**
```python
@computed_field  # type: ignore[prop-decorator]
@property
def SQLALCHEMY_DATABASE_URI_MYSQL(self) -> str:
    """生成 MySQL 数据库连接 URL（异步）"""
    return f"mysql+aiomysql://{self.MYSQL_USER}:{self.MYSQL_PASSWORD}@{self.MYSQL_SERVER}:{self.MYSQL_PORT}/{self.MYSQL_DB}?charset=utf8mb4"
```

**状态：** ✅ 已完成（配置已使用 `mysql+aiomysql://`）

---

## 七、启动文件升级

**需要修改的文件：** `main.py`

**当前代码：**

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.routing import APIRoute
from starlette.middleware.cors import CORSMiddleware

from app.api.main import api_router
from app.core.config import settings
from app.core.db_mysql import create_tables, shutdown_db


def custom_generate_unique_id(route: APIRoute) -> str:
    return f"{route.tags[0]}-{route.name}"


@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 应用启动时执行
    print("应用启动中...")
    create_tables()  # 调用同步函数
    print("应用启动完成")
    yield
    # 应用关闭时执行
    print("应用关闭中...")
    shutdown_db()  # 调用同步函数
    print("应用关闭完成")


app = FastAPI(
    title=settings.PROJECT_NAME,  # API 文档标题，来自配置文件
    openapi_url=f"{settings.API_V1_STR}/openapi.json",  # OpenAPI 文档的 URL 路径
    generate_unique_id_function=custom_generate_unique_id,  # 自定义路由 ID 生成函数
    lifespan=lifespan,  # 使用生命周期管理
)

if settings.all_cors_origins:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.all_cors_origins,  # 允许的来源列表，来自配置文件
        allow_credentials=True,  # 允许携带凭证（如 cookies）
        allow_methods=["*"],  # 允许所有 HTTP 方法
        allow_headers=["*"],  # 允许所有 HTTP 头部
    )

app.include_router(api_router, prefix=settings.API_V1_STR)
```

**修改后代码：**

```python
from contextlib import asynccontextmanager
from fastapi import FastAPI
from fastapi.routing import APIRoute
from starlette.middleware.cors import CORSMiddleware

from app.api.main import api_router
from app.core.config import settings
from app.core.db_mysql import create_tables, shutdown_db


def custom_generate_unique_id(route: APIRoute) -> str:
    return f"{route.tags[0]}-{route.name}"


@asynccontextmanager
async def lifespan(app: FastAPI):
    """应用生命周期管理"""
    # 应用启动时执行
    print("应用启动中...")
    await create_tables()  # 调用异步函数
    print("应用启动完成")
    yield
    # 应用关闭时执行
    print("应用关闭中...")
    await shutdown_db()  # 调用异步函数
    print("应用关闭完成")


app = FastAPI(
    title=settings.PROJECT_NAME,  # API 文档标题，来自配置文件
    openapi_url=f"{settings.API_V1_STR}/openapi.json",  # OpenAPI 文档的 URL 路径
    generate_unique_id_function=custom_generate_unique_id,  # 自定义路由 ID 生成函数
    lifespan=lifespan,  # 使用生命周期管理
)

if settings.all_cors_origins:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.all_cors_origins,  # 允许的来源列表，来自配置文件
        allow_credentials=True,  # 允许携带凭证（如 cookies）
        allow_methods=["*"],  # 允许所有 HTTP 方法
        allow_headers=["*"],  # 允许所有 HTTP 头部
    )

app.include_router(api_router, prefix=settings.API_V1_STR)
```

**关键变化：**
- ✅ `create_tables()` → `await create_tables()`
- ✅ `shutdown_db()` → `await shutdown_db()`

---

## 八、模型层（无需修改）

**文件：** `app/models/users_models.py`

**状态：** ✅ 无需修改

**说明：**
- SQLAlchemy 2.0+ 的模型定义同时支持同步和异步，无需修改
- 使用 `Mapped` 和 `mapped_column` 的声明式模型已经是异步兼容的

---

## 九、文件修改清单

| 文件路径                     | 是否需要修改 | 修改类型           | 状态       |
| ---------------------------- | ------------ | ------------------ | ---------- |
| `pyproject.toml`             | ✅ 是         | 添加依赖           | ✅ 已完成   |
| `app/core/config.py`         | ✅ 是         | 添加异步URI配置    | ✅ 已完成   |
| `app/core/db.py`             | ✅ 是         | 升级为异步引擎     | ✅ 已完成   |
| `app/api/deps.py`            | ✅ 是         | 升级为异步会话依赖 | ✅ 已完成   |
| `app/crud/users_crud.py`     | ✅ 是         | 升级为异步CRUD     | ✅ 已完成   |
| `app/api/routes/v1/users.py` | ✅ 是         | 升级为异步路由     | ✅ 已完成   |
| `app/api/routes/v1/login.py` | ✅ 是         | 升级为异步路由     | ✅ 已完成   |
| `main.py`                    | ✅ 是         | 升级为异步调用     | ✅ 已完成   |
| `app/models/users_models.py` | ❌ 否         | 无需修改           | ✅ 无需修改 |
| `app/models/base_models.py`  | ❌ 否         | 无需修改           | ✅ 无需修改 |
| `app/models/token_models.py` | ❌ 否         | 无需修改           | ✅ 无需修改 |
| `app/core/security.py`       | ❌ 否         | 无需修改           | ✅ 无需修改 |

---

## 十、升级步骤建议

### 阶段一：准备阶段 ✅ 已完成
1. ✅ 备份当前代码
2. ✅ 更新 `pyproject.toml` 依赖
3. ✅ 运行 `pip install` 安装新依赖

### 阶段二：核心层升级
4. ✅ 修改配置文件，添加异步数据库URI（已完成）
5. ✅ 升级数据库引擎层
6. ✅ 升级数据库会话依赖

### 阶段三：业务层升级
7. ✅ 升级CRUD层
8. ✅ 升级路由层
9. ✅ 升级启动文件

### 阶段四：测试验证
10. ⏳ 单元测试
11. ⏳ 集成测试
12. ⏳ 性能测试

---

## 十一、关键API对照表

| 同步API                   | 异步API                            | 说明         |
| ------------------------- | ---------------------------------- | ------------ |
| `Session(engine)`         | `AsyncSession(engine)`             | 会话类型     |
| `session.exec(statement)` | `await session.execute(statement)` | 执行查询     |
| `result.first()`          | `result.scalar_one_or_none()`      | 获取单条记录 |
| `session.commit()`        | `await session.commit()`           | 提交事务     |
| `session.rollback()`      | `await session.rollback()`         | 回滚事务     |
| `session.refresh(obj)`    | `await session.refresh(obj)`       | 刷新对象     |
| `session.close()`         | `await session.close()`            | 关闭会话     |
| `engine.dispose()`        | `await engine.dispose()`           | 关闭引擎     |

---

## 十二、注意事项

| 序号 | 注意事项     | 说明                                                     |
| ---- | ------------ | -------------------------------------------------------- |
| 12.1 | 混合使用风险 | 不要在异步函数中调用同步数据库操作，会阻塞事件循环       |
| 12.2 | 会话管理     | 异步会话必须正确关闭，使用 `async with` 或 `try/finally` |
| 12.3 | 错误处理     | 异步操作的异常处理需要使用 `try/except` 包裹 `await`     |
| 12.4 | 向后兼容     | 如果需要保留同步接口，可以考虑同时提供同步和异步版本     |
| 12.5 | 性能监控     | 升级后监控数据库连接池使用情况，调整连接池大小           |

---

## 十三、预期收益

| 收益项     | 说明                                    |
| ---------- | --------------------------------------- |
| 性能提升   | 异步I/O可以处理更多并发请求，提升吞吐量 |
| 资源利用率 | 减少线程切换开销，更高效利用CPU和内存   |
| 可扩展性   | 更容易水平扩展，支持更高的并发用户数    |
| 现代化     | 符合Python异步编程的最佳实践，便于维护  |

---

## 十四、风险评估

| 风险项         | 风险等级 | 缓解措施                              |
| -------------- | -------- | ------------------------------------- |
| 破坏性变更     | 中       | 充分测试，分阶段升级                  |
| 学习曲线       | 低       | SQLAlchemy 2.0+ API设计良好，易于理解 |
| 第三方库兼容性 | 低       | FastAPI原生支持异步，大多数库已适配   |
| 调试难度       | 中       | 使用异步调试工具，如aiodebug          |

---

**文档版本：** 2.0
**创建日期：** 2026-1-19
**更新日期：** 2026-1-19
**适用项目：** fastapi-template
**状态：** 依赖和配置已完成，待升级核心层和业务层
